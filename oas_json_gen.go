// Code generated by ogen, DO NOT EDIT.

package browserbase

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *BrowserbaseProxyConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BrowserbaseProxyConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.DomainPattern.Set {
			e.FieldStart("domainPattern")
			s.DomainPattern.Encode(e)
		}
	}
	{
		if s.Geolocation.Set {
			e.FieldStart("geolocation")
			s.Geolocation.Encode(e)
		}
	}
}

var jsonFieldsNameOfBrowserbaseProxyConfig = [3]string{
	0: "type",
	1: "domainPattern",
	2: "geolocation",
}

// Decode decodes BrowserbaseProxyConfig from json.
func (s *BrowserbaseProxyConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BrowserbaseProxyConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "domainPattern":
			if err := func() error {
				s.DomainPattern.Reset()
				if err := s.DomainPattern.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainPattern\"")
			}
		case "geolocation":
			if err := func() error {
				s.Geolocation.Reset()
				if err := s.Geolocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"geolocation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BrowserbaseProxyConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBrowserbaseProxyConfig) {
					name = jsonFieldsNameOfBrowserbaseProxyConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BrowserbaseProxyConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BrowserbaseProxyConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BrowserbaseProxyConfigType as json.
func (s BrowserbaseProxyConfigType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BrowserbaseProxyConfigType from json.
func (s *BrowserbaseProxyConfigType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BrowserbaseProxyConfigType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BrowserbaseProxyConfigType(v) {
	case BrowserbaseProxyConfigTypeBrowserbase:
		*s = BrowserbaseProxyConfigTypeBrowserbase
	default:
		*s = BrowserbaseProxyConfigType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BrowserbaseProxyConfigType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BrowserbaseProxyConfigType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Context) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Context) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("projectId")
		e.Str(s.ProjectId)
	}
	{
		e.FieldStart("createdAt")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		e.Str(s.UpdatedAt)
	}
}

var jsonFieldsNameOfContext = [4]string{
	0: "id",
	1: "projectId",
	2: "createdAt",
	3: "updatedAt",
}

// Decode decodes Context from json.
func (s *Context) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Context to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "projectId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ProjectId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Context")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContext) {
					name = jsonFieldsNameOfContext[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Context) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Context) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContextCreateParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContextCreateParams) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("projectId")
		e.Str(s.ProjectId)
	}
}

var jsonFieldsNameOfContextCreateParams = [1]string{
	0: "projectId",
}

// Decode decodes ContextCreateParams from json.
func (s *ContextCreateParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContextCreateParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "projectId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ProjectId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContextCreateParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContextCreateParams) {
					name = jsonFieldsNameOfContextCreateParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContextCreateParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContextCreateParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContextCreateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContextCreateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("cipherAlgorithm")
		e.Str(s.CipherAlgorithm)
	}
	{
		e.FieldStart("initializationVectorSize")
		e.Int(s.InitializationVectorSize)
	}
	{
		e.FieldStart("publicKey")
		e.Str(s.PublicKey)
	}
	{
		e.FieldStart("uploadUrl")
		e.Str(s.UploadUrl)
	}
}

var jsonFieldsNameOfContextCreateResponse = [5]string{
	0: "id",
	1: "cipherAlgorithm",
	2: "initializationVectorSize",
	3: "publicKey",
	4: "uploadUrl",
}

// Decode decodes ContextCreateResponse from json.
func (s *ContextCreateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContextCreateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "cipherAlgorithm":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CipherAlgorithm = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cipherAlgorithm\"")
			}
		case "initializationVectorSize":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.InitializationVectorSize = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initializationVectorSize\"")
			}
		case "publicKey":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.PublicKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicKey\"")
			}
		case "uploadUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.UploadUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploadUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContextCreateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContextCreateResponse) {
					name = jsonFieldsNameOfContextCreateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContextCreateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContextCreateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Extension) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Extension) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("createdAt")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("fileName")
		e.Str(s.FileName)
	}
	{
		e.FieldStart("projectId")
		e.Str(s.ProjectId)
	}
	{
		e.FieldStart("updatedAt")
		e.Str(s.UpdatedAt)
	}
}

var jsonFieldsNameOfExtension = [5]string{
	0: "id",
	1: "createdAt",
	2: "fileName",
	3: "projectId",
	4: "updatedAt",
}

// Decode decodes Extension from json.
func (s *Extension) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Extension to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "fileName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FileName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fileName\"")
			}
		case "projectId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ProjectId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Extension")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExtension) {
					name = jsonFieldsNameOfExtension[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Extension) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Extension) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalProxyConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalProxyConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("server")
		e.Str(s.Server)
	}
	{
		if s.DomainPattern.Set {
			e.FieldStart("domainPattern")
			s.DomainPattern.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
}

var jsonFieldsNameOfExternalProxyConfig = [5]string{
	0: "type",
	1: "server",
	2: "domainPattern",
	3: "password",
	4: "username",
}

// Decode decodes ExternalProxyConfig from json.
func (s *ExternalProxyConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalProxyConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "server":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Server = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server\"")
			}
		case "domainPattern":
			if err := func() error {
				s.DomainPattern.Reset()
				if err := s.DomainPattern.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainPattern\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalProxyConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExternalProxyConfig) {
					name = jsonFieldsNameOfExternalProxyConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalProxyConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalProxyConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExternalProxyConfigType as json.
func (s ExternalProxyConfigType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExternalProxyConfigType from json.
func (s *ExternalProxyConfigType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalProxyConfigType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExternalProxyConfigType(v) {
	case ExternalProxyConfigTypeExternal:
		*s = ExternalProxyConfigTypeExternal
	default:
		*s = ExternalProxyConfigType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExternalProxyConfigType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalProxyConfigType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Geolocation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Geolocation) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("country")
		e.Str(s.Country)
	}
	{
		if s.City.Set {
			e.FieldStart("city")
			s.City.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
}

var jsonFieldsNameOfGeolocation = [3]string{
	0: "country",
	1: "city",
	2: "state",
}

// Decode decodes Geolocation from json.
func (s *Geolocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Geolocation to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "country":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Country = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "city":
			if err := func() error {
				s.City.Reset()
				if err := s.City.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"city\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Geolocation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGeolocation) {
					name = jsonFieldsNameOfGeolocation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Geolocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Geolocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LogListResponse as json.
func (s LogListResponse) Encode(e *jx.Encoder) {
	unwrapped := []SessionLog(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes LogListResponse from json.
func (s *LogListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogListResponse to nil")
	}
	var unwrapped []SessionLog
	if err := func() error {
		unwrapped = make([]SessionLog, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SessionLog
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LogListResponse(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LogListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Geolocation as json.
func (o OptGeolocation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Geolocation from json.
func (o *OptGeolocation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGeolocation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGeolocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGeolocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionCreateResponseUserMetadata as json.
func (o OptNilSessionCreateResponseUserMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionCreateResponseUserMetadata from json.
func (o *OptNilSessionCreateResponseUserMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSessionCreateResponseUserMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SessionCreateResponseUserMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SessionCreateResponseUserMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSessionCreateResponseUserMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSessionCreateResponseUserMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionUserMetadata as json.
func (o OptNilSessionUserMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionUserMetadata from json.
func (o *OptNilSessionUserMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSessionUserMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SessionUserMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SessionUserMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSessionUserMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSessionUserMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionBrowserSettings as json.
func (o OptSessionBrowserSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionBrowserSettings from json.
func (o *OptSessionBrowserSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSessionBrowserSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSessionBrowserSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSessionBrowserSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionBrowserSettingsContext as json.
func (o OptSessionBrowserSettingsContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionBrowserSettingsContext from json.
func (o *OptSessionBrowserSettingsContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSessionBrowserSettingsContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSessionBrowserSettingsContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSessionBrowserSettingsContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionBrowserSettingsFingerprint as json.
func (o OptSessionBrowserSettingsFingerprint) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionBrowserSettingsFingerprint from json.
func (o *OptSessionBrowserSettingsFingerprint) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSessionBrowserSettingsFingerprint to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSessionBrowserSettingsFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSessionBrowserSettingsFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionBrowserSettingsFingerprintHttpVersion as json.
func (o OptSessionBrowserSettingsFingerprintHttpVersion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SessionBrowserSettingsFingerprintHttpVersion from json.
func (o *OptSessionBrowserSettingsFingerprintHttpVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSessionBrowserSettingsFingerprintHttpVersion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSessionBrowserSettingsFingerprintHttpVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSessionBrowserSettingsFingerprintHttpVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionBrowserSettingsFingerprintScreen as json.
func (o OptSessionBrowserSettingsFingerprintScreen) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionBrowserSettingsFingerprintScreen from json.
func (o *OptSessionBrowserSettingsFingerprintScreen) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSessionBrowserSettingsFingerprintScreen to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSessionBrowserSettingsFingerprintScreen) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSessionBrowserSettingsFingerprintScreen) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionBrowserSettingsViewport as json.
func (o OptSessionBrowserSettingsViewport) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionBrowserSettingsViewport from json.
func (o *OptSessionBrowserSettingsViewport) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSessionBrowserSettingsViewport to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSessionBrowserSettingsViewport) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSessionBrowserSettingsViewport) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionCreateParamsProxies as json.
func (o OptSessionCreateParamsProxies) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionCreateParamsProxies from json.
func (o *OptSessionCreateParamsProxies) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSessionCreateParamsProxies to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSessionCreateParamsProxies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSessionCreateParamsProxies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionCreateParamsRegion as json.
func (o OptSessionCreateParamsRegion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SessionCreateParamsRegion from json.
func (o *OptSessionCreateParamsRegion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSessionCreateParamsRegion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSessionCreateParamsRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSessionCreateParamsRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionCreateParamsUserMetadata as json.
func (o OptSessionCreateParamsUserMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionCreateParamsUserMetadata from json.
func (o *OptSessionCreateParamsUserMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSessionCreateParamsUserMetadata to nil")
	}
	o.Set = true
	o.Value = make(SessionCreateParamsUserMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSessionCreateParamsUserMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSessionCreateParamsUserMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionLogRequest as json.
func (o OptSessionLogRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionLogRequest from json.
func (o *OptSessionLogRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSessionLogRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSessionLogRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSessionLogRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionLogResponse as json.
func (o OptSessionLogResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SessionLogResponse from json.
func (o *OptSessionLogResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSessionLogResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSessionLogResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSessionLogResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Project) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Project) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("concurrency")
		e.Int(s.Concurrency)
	}
	{
		e.FieldStart("createdAt")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("defaultTimeout")
		e.Int(s.DefaultTimeout)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("ownerId")
		e.Str(s.OwnerId)
	}
	{
		e.FieldStart("updatedAt")
		e.Str(s.UpdatedAt)
	}
}

var jsonFieldsNameOfProject = [7]string{
	0: "id",
	1: "concurrency",
	2: "createdAt",
	3: "defaultTimeout",
	4: "name",
	5: "ownerId",
	6: "updatedAt",
}

// Decode decodes Project from json.
func (s *Project) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Project to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "concurrency":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Concurrency = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"concurrency\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "defaultTimeout":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DefaultTimeout = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultTimeout\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "ownerId":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.OwnerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ownerId\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Project")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProject) {
					name = jsonFieldsNameOfProject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Project) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Project) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectListResponse as json.
func (s ProjectListResponse) Encode(e *jx.Encoder) {
	unwrapped := []Project(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ProjectListResponse from json.
func (s *ProjectListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectListResponse to nil")
	}
	var unwrapped []Project
	if err := func() error {
		unwrapped = make([]Project, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Project
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectListResponse(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectUsage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("browserMinutes")
		e.Float64(s.BrowserMinutes)
	}
	{
		e.FieldStart("proxyBytes")
		e.Float64(s.ProxyBytes)
	}
}

var jsonFieldsNameOfProjectUsage = [2]string{
	0: "browserMinutes",
	1: "proxyBytes",
}

// Decode decodes ProjectUsage from json.
func (s *ProjectUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "browserMinutes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.BrowserMinutes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"browserMinutes\"")
			}
		case "proxyBytes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.ProxyBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxyBytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectUsage) {
					name = jsonFieldsNameOfProjectUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingRetrieveResponse as json.
func (s RecordingRetrieveResponse) Encode(e *jx.Encoder) {
	unwrapped := []SessionRecording(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes RecordingRetrieveResponse from json.
func (s *RecordingRetrieveResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingRetrieveResponse to nil")
	}
	var unwrapped []SessionRecording
	if err := func() error {
		unwrapped = make([]SessionRecording, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SessionRecording
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RecordingRetrieveResponse(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecordingRetrieveResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingRetrieveResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Session) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Session) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("createdAt")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("expiresAt")
		e.Str(s.ExpiresAt)
	}
	{
		e.FieldStart("keepAlive")
		e.Bool(s.KeepAlive)
	}
	{
		e.FieldStart("projectId")
		e.Str(s.ProjectId)
	}
	{
		e.FieldStart("proxyBytes")
		e.Float64(s.ProxyBytes)
	}
	{
		e.FieldStart("region")
		s.Region.Encode(e)
	}
	{
		e.FieldStart("startedAt")
		e.Str(s.StartedAt)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("updatedAt")
		e.Str(s.UpdatedAt)
	}
	{
		if s.AvgCpuUsage.Set {
			e.FieldStart("avgCpuUsage")
			s.AvgCpuUsage.Encode(e)
		}
	}
	{
		if s.ContextId.Set {
			e.FieldStart("contextId")
			s.ContextId.Encode(e)
		}
	}
	{
		if s.EndedAt.Set {
			e.FieldStart("endedAt")
			s.EndedAt.Encode(e)
		}
	}
	{
		if s.MemoryUsage.Set {
			e.FieldStart("memoryUsage")
			s.MemoryUsage.Encode(e)
		}
	}
	{
		if s.UserMetadata.Set {
			e.FieldStart("userMetadata")
			s.UserMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfSession = [15]string{
	0:  "id",
	1:  "createdAt",
	2:  "expiresAt",
	3:  "keepAlive",
	4:  "projectId",
	5:  "proxyBytes",
	6:  "region",
	7:  "startedAt",
	8:  "status",
	9:  "updatedAt",
	10: "avgCpuUsage",
	11: "contextId",
	12: "endedAt",
	13: "memoryUsage",
	14: "userMetadata",
}

// Decode decodes Session from json.
func (s *Session) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Session to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "expiresAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ExpiresAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "keepAlive":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.KeepAlive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keepAlive\"")
			}
		case "projectId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ProjectId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "proxyBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.ProxyBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxyBytes\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "startedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.StartedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startedAt\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "updatedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "avgCpuUsage":
			if err := func() error {
				s.AvgCpuUsage.Reset()
				if err := s.AvgCpuUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avgCpuUsage\"")
			}
		case "contextId":
			if err := func() error {
				s.ContextId.Reset()
				if err := s.ContextId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextId\"")
			}
		case "endedAt":
			if err := func() error {
				s.EndedAt.Reset()
				if err := s.EndedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endedAt\"")
			}
		case "memoryUsage":
			if err := func() error {
				s.MemoryUsage.Reset()
				if err := s.MemoryUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryUsage\"")
			}
		case "userMetadata":
			if err := func() error {
				s.UserMetadata.Reset()
				if err := s.UserMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Session")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSession) {
					name = jsonFieldsNameOfSession[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Session) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Session) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionBrowserSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionBrowserSettings) encodeFields(e *jx.Encoder) {
	{
		if s.AdvancedStealth.Set {
			e.FieldStart("advancedStealth")
			s.AdvancedStealth.Encode(e)
		}
	}
	{
		if s.BlockAds.Set {
			e.FieldStart("blockAds")
			s.BlockAds.Encode(e)
		}
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.ExtensionId.Set {
			e.FieldStart("extensionId")
			s.ExtensionId.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.LogSession.Set {
			e.FieldStart("logSession")
			s.LogSession.Encode(e)
		}
	}
	{
		if s.RecordSession.Set {
			e.FieldStart("recordSession")
			s.RecordSession.Encode(e)
		}
	}
	{
		if s.SolveCaptchas.Set {
			e.FieldStart("solveCaptchas")
			s.SolveCaptchas.Encode(e)
		}
	}
	{
		if s.Viewport.Set {
			e.FieldStart("viewport")
			s.Viewport.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionBrowserSettings = [9]string{
	0: "advancedStealth",
	1: "blockAds",
	2: "context",
	3: "extensionId",
	4: "fingerprint",
	5: "logSession",
	6: "recordSession",
	7: "solveCaptchas",
	8: "viewport",
}

// Decode decodes SessionBrowserSettings from json.
func (s *SessionBrowserSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionBrowserSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "advancedStealth":
			if err := func() error {
				s.AdvancedStealth.Reset()
				if err := s.AdvancedStealth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"advancedStealth\"")
			}
		case "blockAds":
			if err := func() error {
				s.BlockAds.Reset()
				if err := s.BlockAds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockAds\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "extensionId":
			if err := func() error {
				s.ExtensionId.Reset()
				if err := s.ExtensionId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extensionId\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "logSession":
			if err := func() error {
				s.LogSession.Reset()
				if err := s.LogSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logSession\"")
			}
		case "recordSession":
			if err := func() error {
				s.RecordSession.Reset()
				if err := s.RecordSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordSession\"")
			}
		case "solveCaptchas":
			if err := func() error {
				s.SolveCaptchas.Reset()
				if err := s.SolveCaptchas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"solveCaptchas\"")
			}
		case "viewport":
			if err := func() error {
				s.Viewport.Reset()
				if err := s.Viewport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewport\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionBrowserSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionBrowserSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionBrowserSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionBrowserSettingsContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionBrowserSettingsContext) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Persist.Set {
			e.FieldStart("persist")
			s.Persist.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionBrowserSettingsContext = [2]string{
	0: "id",
	1: "persist",
}

// Decode decodes SessionBrowserSettingsContext from json.
func (s *SessionBrowserSettingsContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionBrowserSettingsContext to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "persist":
			if err := func() error {
				s.Persist.Reset()
				if err := s.Persist.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persist\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionBrowserSettingsContext")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionBrowserSettingsContext) {
					name = jsonFieldsNameOfSessionBrowserSettingsContext[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionBrowserSettingsContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionBrowserSettingsContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionBrowserSettingsFingerprint) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionBrowserSettingsFingerprint) encodeFields(e *jx.Encoder) {
	{
		if s.Browsers != nil {
			e.FieldStart("browsers")
			e.ArrStart()
			for _, elem := range s.Browsers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Devices != nil {
			e.FieldStart("devices")
			e.ArrStart()
			for _, elem := range s.Devices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HttpVersion.Set {
			e.FieldStart("httpVersion")
			s.HttpVersion.Encode(e)
		}
	}
	{
		if s.Locales != nil {
			e.FieldStart("locales")
			e.ArrStart()
			for _, elem := range s.Locales {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OperatingSystems != nil {
			e.FieldStart("operatingSystems")
			e.ArrStart()
			for _, elem := range s.OperatingSystems {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Screen.Set {
			e.FieldStart("screen")
			s.Screen.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionBrowserSettingsFingerprint = [6]string{
	0: "browsers",
	1: "devices",
	2: "httpVersion",
	3: "locales",
	4: "operatingSystems",
	5: "screen",
}

// Decode decodes SessionBrowserSettingsFingerprint from json.
func (s *SessionBrowserSettingsFingerprint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionBrowserSettingsFingerprint to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "browsers":
			if err := func() error {
				s.Browsers = make([]SessionBrowserSettingsFingerprintBrowsersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SessionBrowserSettingsFingerprintBrowsersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Browsers = append(s.Browsers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"browsers\"")
			}
		case "devices":
			if err := func() error {
				s.Devices = make([]SessionBrowserSettingsFingerprintDevicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SessionBrowserSettingsFingerprintDevicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Devices = append(s.Devices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devices\"")
			}
		case "httpVersion":
			if err := func() error {
				s.HttpVersion.Reset()
				if err := s.HttpVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpVersion\"")
			}
		case "locales":
			if err := func() error {
				s.Locales = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Locales = append(s.Locales, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locales\"")
			}
		case "operatingSystems":
			if err := func() error {
				s.OperatingSystems = make([]SessionBrowserSettingsFingerprintOperatingSystemsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SessionBrowserSettingsFingerprintOperatingSystemsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OperatingSystems = append(s.OperatingSystems, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operatingSystems\"")
			}
		case "screen":
			if err := func() error {
				s.Screen.Reset()
				if err := s.Screen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"screen\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionBrowserSettingsFingerprint")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionBrowserSettingsFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionBrowserSettingsFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionBrowserSettingsFingerprintBrowsersItem as json.
func (s SessionBrowserSettingsFingerprintBrowsersItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SessionBrowserSettingsFingerprintBrowsersItem from json.
func (s *SessionBrowserSettingsFingerprintBrowsersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionBrowserSettingsFingerprintBrowsersItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SessionBrowserSettingsFingerprintBrowsersItem(v) {
	case SessionBrowserSettingsFingerprintBrowsersItemChrome:
		*s = SessionBrowserSettingsFingerprintBrowsersItemChrome
	case SessionBrowserSettingsFingerprintBrowsersItemEdge:
		*s = SessionBrowserSettingsFingerprintBrowsersItemEdge
	case SessionBrowserSettingsFingerprintBrowsersItemFirefox:
		*s = SessionBrowserSettingsFingerprintBrowsersItemFirefox
	case SessionBrowserSettingsFingerprintBrowsersItemSafari:
		*s = SessionBrowserSettingsFingerprintBrowsersItemSafari
	default:
		*s = SessionBrowserSettingsFingerprintBrowsersItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionBrowserSettingsFingerprintBrowsersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionBrowserSettingsFingerprintBrowsersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionBrowserSettingsFingerprintDevicesItem as json.
func (s SessionBrowserSettingsFingerprintDevicesItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SessionBrowserSettingsFingerprintDevicesItem from json.
func (s *SessionBrowserSettingsFingerprintDevicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionBrowserSettingsFingerprintDevicesItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SessionBrowserSettingsFingerprintDevicesItem(v) {
	case SessionBrowserSettingsFingerprintDevicesItemDesktop:
		*s = SessionBrowserSettingsFingerprintDevicesItemDesktop
	case SessionBrowserSettingsFingerprintDevicesItemMobile:
		*s = SessionBrowserSettingsFingerprintDevicesItemMobile
	default:
		*s = SessionBrowserSettingsFingerprintDevicesItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionBrowserSettingsFingerprintDevicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionBrowserSettingsFingerprintDevicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionBrowserSettingsFingerprintHttpVersion as json.
func (s SessionBrowserSettingsFingerprintHttpVersion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SessionBrowserSettingsFingerprintHttpVersion from json.
func (s *SessionBrowserSettingsFingerprintHttpVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionBrowserSettingsFingerprintHttpVersion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SessionBrowserSettingsFingerprintHttpVersion(v) {
	case SessionBrowserSettingsFingerprintHttpVersion1:
		*s = SessionBrowserSettingsFingerprintHttpVersion1
	case SessionBrowserSettingsFingerprintHttpVersion2:
		*s = SessionBrowserSettingsFingerprintHttpVersion2
	default:
		*s = SessionBrowserSettingsFingerprintHttpVersion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionBrowserSettingsFingerprintHttpVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionBrowserSettingsFingerprintHttpVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionBrowserSettingsFingerprintOperatingSystemsItem as json.
func (s SessionBrowserSettingsFingerprintOperatingSystemsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SessionBrowserSettingsFingerprintOperatingSystemsItem from json.
func (s *SessionBrowserSettingsFingerprintOperatingSystemsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionBrowserSettingsFingerprintOperatingSystemsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SessionBrowserSettingsFingerprintOperatingSystemsItem(v) {
	case SessionBrowserSettingsFingerprintOperatingSystemsItemAndroid:
		*s = SessionBrowserSettingsFingerprintOperatingSystemsItemAndroid
	case SessionBrowserSettingsFingerprintOperatingSystemsItemIos:
		*s = SessionBrowserSettingsFingerprintOperatingSystemsItemIos
	case SessionBrowserSettingsFingerprintOperatingSystemsItemLinux:
		*s = SessionBrowserSettingsFingerprintOperatingSystemsItemLinux
	case SessionBrowserSettingsFingerprintOperatingSystemsItemMacos:
		*s = SessionBrowserSettingsFingerprintOperatingSystemsItemMacos
	case SessionBrowserSettingsFingerprintOperatingSystemsItemWindows:
		*s = SessionBrowserSettingsFingerprintOperatingSystemsItemWindows
	default:
		*s = SessionBrowserSettingsFingerprintOperatingSystemsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionBrowserSettingsFingerprintOperatingSystemsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionBrowserSettingsFingerprintOperatingSystemsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionBrowserSettingsFingerprintScreen) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionBrowserSettingsFingerprintScreen) encodeFields(e *jx.Encoder) {
	{
		if s.MaxHeight.Set {
			e.FieldStart("maxHeight")
			s.MaxHeight.Encode(e)
		}
	}
	{
		if s.MaxWidth.Set {
			e.FieldStart("maxWidth")
			s.MaxWidth.Encode(e)
		}
	}
	{
		if s.MinHeight.Set {
			e.FieldStart("minHeight")
			s.MinHeight.Encode(e)
		}
	}
	{
		if s.MinWidth.Set {
			e.FieldStart("minWidth")
			s.MinWidth.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionBrowserSettingsFingerprintScreen = [4]string{
	0: "maxHeight",
	1: "maxWidth",
	2: "minHeight",
	3: "minWidth",
}

// Decode decodes SessionBrowserSettingsFingerprintScreen from json.
func (s *SessionBrowserSettingsFingerprintScreen) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionBrowserSettingsFingerprintScreen to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxHeight":
			if err := func() error {
				s.MaxHeight.Reset()
				if err := s.MaxHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxHeight\"")
			}
		case "maxWidth":
			if err := func() error {
				s.MaxWidth.Reset()
				if err := s.MaxWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxWidth\"")
			}
		case "minHeight":
			if err := func() error {
				s.MinHeight.Reset()
				if err := s.MinHeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minHeight\"")
			}
		case "minWidth":
			if err := func() error {
				s.MinWidth.Reset()
				if err := s.MinWidth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minWidth\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionBrowserSettingsFingerprintScreen")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionBrowserSettingsFingerprintScreen) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionBrowserSettingsFingerprintScreen) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionBrowserSettingsViewport) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionBrowserSettingsViewport) encodeFields(e *jx.Encoder) {
	{
		if s.Height.Set {
			e.FieldStart("height")
			s.Height.Encode(e)
		}
	}
	{
		if s.Width.Set {
			e.FieldStart("width")
			s.Width.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionBrowserSettingsViewport = [2]string{
	0: "height",
	1: "width",
}

// Decode decodes SessionBrowserSettingsViewport from json.
func (s *SessionBrowserSettingsViewport) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionBrowserSettingsViewport to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"height\"")
			}
		case "width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionBrowserSettingsViewport")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionBrowserSettingsViewport) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionBrowserSettingsViewport) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionCreateParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionCreateParams) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("projectId")
		e.Str(s.ProjectId)
	}
	{
		if s.BrowserSettings.Set {
			e.FieldStart("browserSettings")
			s.BrowserSettings.Encode(e)
		}
	}
	{
		if s.ExtensionId.Set {
			e.FieldStart("extensionId")
			s.ExtensionId.Encode(e)
		}
	}
	{
		if s.KeepAlive.Set {
			e.FieldStart("keepAlive")
			s.KeepAlive.Encode(e)
		}
	}
	{
		if s.Proxies.Set {
			e.FieldStart("proxies")
			s.Proxies.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.Timeout.Set {
			e.FieldStart("timeout")
			s.Timeout.Encode(e)
		}
	}
	{
		if s.UserMetadata.Set {
			e.FieldStart("userMetadata")
			s.UserMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionCreateParams = [8]string{
	0: "projectId",
	1: "browserSettings",
	2: "extensionId",
	3: "keepAlive",
	4: "proxies",
	5: "region",
	6: "timeout",
	7: "userMetadata",
}

// Decode decodes SessionCreateParams from json.
func (s *SessionCreateParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionCreateParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "projectId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ProjectId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "browserSettings":
			if err := func() error {
				s.BrowserSettings.Reset()
				if err := s.BrowserSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"browserSettings\"")
			}
		case "extensionId":
			if err := func() error {
				s.ExtensionId.Reset()
				if err := s.ExtensionId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extensionId\"")
			}
		case "keepAlive":
			if err := func() error {
				s.KeepAlive.Reset()
				if err := s.KeepAlive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keepAlive\"")
			}
		case "proxies":
			if err := func() error {
				s.Proxies.Reset()
				if err := s.Proxies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxies\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "timeout":
			if err := func() error {
				s.Timeout.Reset()
				if err := s.Timeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout\"")
			}
		case "userMetadata":
			if err := func() error {
				s.UserMetadata.Reset()
				if err := s.UserMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionCreateParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionCreateParams) {
					name = jsonFieldsNameOfSessionCreateParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionCreateParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionCreateParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionCreateParamsProxies as json.
func (s SessionCreateParamsProxies) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolSessionCreateParamsProxies:
		e.Bool(s.Bool)
	case SessionCreateParamsProxies1ItemArraySessionCreateParamsProxies:
		e.ArrStart()
		for _, elem := range s.SessionCreateParamsProxies1ItemArray {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes SessionCreateParamsProxies from json.
func (s *SessionCreateParamsProxies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionCreateParamsProxies to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.SessionCreateParamsProxies1ItemArray = make([]SessionCreateParamsProxies1Item, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SessionCreateParamsProxies1Item
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.SessionCreateParamsProxies1ItemArray = append(s.SessionCreateParamsProxies1ItemArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = SessionCreateParamsProxies1ItemArraySessionCreateParamsProxies
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolSessionCreateParamsProxies
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionCreateParamsProxies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionCreateParamsProxies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionCreateParamsProxies1Item as json.
func (s SessionCreateParamsProxies1Item) Encode(e *jx.Encoder) {
	switch s.Type {
	case BrowserbaseProxyConfigSessionCreateParamsProxies1Item:
		s.BrowserbaseProxyConfig.Encode(e)
	case ExternalProxyConfigSessionCreateParamsProxies1Item:
		s.ExternalProxyConfig.Encode(e)
	}
}

func (s SessionCreateParamsProxies1Item) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case BrowserbaseProxyConfigSessionCreateParamsProxies1Item:
		s.BrowserbaseProxyConfig.encodeFields(e)
	case ExternalProxyConfigSessionCreateParamsProxies1Item:
		s.ExternalProxyConfig.encodeFields(e)
	}
}

// Decode decodes SessionCreateParamsProxies1Item from json.
func (s *SessionCreateParamsProxies1Item) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionCreateParamsProxies1Item to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "geolocation":
				match := BrowserbaseProxyConfigSessionCreateParamsProxies1Item
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "server":
				match := ExternalProxyConfigSessionCreateParamsProxies1Item
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "password":
				match := ExternalProxyConfigSessionCreateParamsProxies1Item
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "username":
				match := ExternalProxyConfigSessionCreateParamsProxies1Item
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case BrowserbaseProxyConfigSessionCreateParamsProxies1Item:
		if err := s.BrowserbaseProxyConfig.Decode(d); err != nil {
			return err
		}
	case ExternalProxyConfigSessionCreateParamsProxies1Item:
		if err := s.ExternalProxyConfig.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionCreateParamsProxies1Item) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionCreateParamsProxies1Item) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionCreateParamsRegion as json.
func (s SessionCreateParamsRegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SessionCreateParamsRegion from json.
func (s *SessionCreateParamsRegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionCreateParamsRegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SessionCreateParamsRegion(v) {
	case SessionCreateParamsRegionUsWest2:
		*s = SessionCreateParamsRegionUsWest2
	case SessionCreateParamsRegionUsEast1:
		*s = SessionCreateParamsRegionUsEast1
	case SessionCreateParamsRegionEuCentral1:
		*s = SessionCreateParamsRegionEuCentral1
	case SessionCreateParamsRegionApSoutheast1:
		*s = SessionCreateParamsRegionApSoutheast1
	default:
		*s = SessionCreateParamsRegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionCreateParamsRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionCreateParamsRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SessionCreateParamsUserMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SessionCreateParamsUserMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SessionCreateParamsUserMetadata from json.
func (s *SessionCreateParamsUserMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionCreateParamsUserMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionCreateParamsUserMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionCreateParamsUserMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionCreateParamsUserMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionCreateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionCreateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("createdAt")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("expiresAt")
		e.Str(s.ExpiresAt)
	}
	{
		e.FieldStart("keepAlive")
		e.Bool(s.KeepAlive)
	}
	{
		e.FieldStart("projectId")
		e.Str(s.ProjectId)
	}
	{
		e.FieldStart("proxyBytes")
		e.Float64(s.ProxyBytes)
	}
	{
		e.FieldStart("region")
		s.Region.Encode(e)
	}
	{
		e.FieldStart("startedAt")
		e.Str(s.StartedAt)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("updatedAt")
		e.Str(s.UpdatedAt)
	}
	{
		if s.AvgCpuUsage.Set {
			e.FieldStart("avgCpuUsage")
			s.AvgCpuUsage.Encode(e)
		}
	}
	{
		if s.ContextId.Set {
			e.FieldStart("contextId")
			s.ContextId.Encode(e)
		}
	}
	{
		if s.EndedAt.Set {
			e.FieldStart("endedAt")
			s.EndedAt.Encode(e)
		}
	}
	{
		if s.MemoryUsage.Set {
			e.FieldStart("memoryUsage")
			s.MemoryUsage.Encode(e)
		}
	}
	{
		if s.UserMetadata.Set {
			e.FieldStart("userMetadata")
			s.UserMetadata.Encode(e)
		}
	}
	{
		e.FieldStart("connectUrl")
		e.Str(s.ConnectUrl)
	}
	{
		e.FieldStart("seleniumRemoteUrl")
		e.Str(s.SeleniumRemoteUrl)
	}
	{
		e.FieldStart("signingKey")
		e.Str(s.SigningKey)
	}
}

var jsonFieldsNameOfSessionCreateResponse = [18]string{
	0:  "id",
	1:  "createdAt",
	2:  "expiresAt",
	3:  "keepAlive",
	4:  "projectId",
	5:  "proxyBytes",
	6:  "region",
	7:  "startedAt",
	8:  "status",
	9:  "updatedAt",
	10: "avgCpuUsage",
	11: "contextId",
	12: "endedAt",
	13: "memoryUsage",
	14: "userMetadata",
	15: "connectUrl",
	16: "seleniumRemoteUrl",
	17: "signingKey",
}

// Decode decodes SessionCreateResponse from json.
func (s *SessionCreateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionCreateResponse to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "expiresAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ExpiresAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "keepAlive":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.KeepAlive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keepAlive\"")
			}
		case "projectId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ProjectId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "proxyBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.ProxyBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxyBytes\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "startedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.StartedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startedAt\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "updatedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "avgCpuUsage":
			if err := func() error {
				s.AvgCpuUsage.Reset()
				if err := s.AvgCpuUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avgCpuUsage\"")
			}
		case "contextId":
			if err := func() error {
				s.ContextId.Reset()
				if err := s.ContextId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contextId\"")
			}
		case "endedAt":
			if err := func() error {
				s.EndedAt.Reset()
				if err := s.EndedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endedAt\"")
			}
		case "memoryUsage":
			if err := func() error {
				s.MemoryUsage.Reset()
				if err := s.MemoryUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryUsage\"")
			}
		case "userMetadata":
			if err := func() error {
				s.UserMetadata.Reset()
				if err := s.UserMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userMetadata\"")
			}
		case "connectUrl":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ConnectUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectUrl\"")
			}
		case "seleniumRemoteUrl":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SeleniumRemoteUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seleniumRemoteUrl\"")
			}
		case "signingKey":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SigningKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signingKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionCreateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b10000011,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionCreateResponse) {
					name = jsonFieldsNameOfSessionCreateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionCreateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionCreateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionCreateResponseRegion as json.
func (s SessionCreateResponseRegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SessionCreateResponseRegion from json.
func (s *SessionCreateResponseRegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionCreateResponseRegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SessionCreateResponseRegion(v) {
	case SessionCreateResponseRegionUsWest2:
		*s = SessionCreateResponseRegionUsWest2
	case SessionCreateResponseRegionUsEast1:
		*s = SessionCreateResponseRegionUsEast1
	case SessionCreateResponseRegionEuCentral1:
		*s = SessionCreateResponseRegionEuCentral1
	case SessionCreateResponseRegionApSoutheast1:
		*s = SessionCreateResponseRegionApSoutheast1
	default:
		*s = SessionCreateResponseRegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionCreateResponseRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionCreateResponseRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SessionCreateResponseUserMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SessionCreateResponseUserMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SessionCreateResponseUserMetadata from json.
func (s *SessionCreateResponseUserMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionCreateResponseUserMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionCreateResponseUserMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionCreateResponseUserMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionCreateResponseUserMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionListResponse as json.
func (s SessionListResponse) Encode(e *jx.Encoder) {
	unwrapped := []Session(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes SessionListResponse from json.
func (s *SessionListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionListResponse to nil")
	}
	var unwrapped []Session
	if err := func() error {
		unwrapped = make([]Session, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Session
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SessionListResponse(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionLiveURLs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionLiveURLs) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("debuggerFullscreenUrl")
		e.Str(s.DebuggerFullscreenUrl)
	}
	{
		e.FieldStart("debuggerUrl")
		e.Str(s.DebuggerUrl)
	}
	{
		e.FieldStart("wsUrl")
		e.Str(s.WsUrl)
	}
	{
		e.FieldStart("pages")
		e.ArrStart()
		for _, elem := range s.Pages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSessionLiveURLs = [4]string{
	0: "debuggerFullscreenUrl",
	1: "debuggerUrl",
	2: "wsUrl",
	3: "pages",
}

// Decode decodes SessionLiveURLs from json.
func (s *SessionLiveURLs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionLiveURLs to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "debuggerFullscreenUrl":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DebuggerFullscreenUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"debuggerFullscreenUrl\"")
			}
		case "debuggerUrl":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DebuggerUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"debuggerUrl\"")
			}
		case "wsUrl":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.WsUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wsUrl\"")
			}
		case "pages":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Pages = make([]SessionLiveURLsPage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SessionLiveURLsPage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Pages = append(s.Pages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionLiveURLs")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionLiveURLs) {
					name = jsonFieldsNameOfSessionLiveURLs[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionLiveURLs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionLiveURLs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionLiveURLsPage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionLiveURLsPage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("debuggerFullscreenUrl")
		e.Str(s.DebuggerFullscreenUrl)
	}
	{
		e.FieldStart("debuggerUrl")
		e.Str(s.DebuggerUrl)
	}
	{
		e.FieldStart("faviconUrl")
		e.Str(s.FaviconUrl)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfSessionLiveURLsPage = [6]string{
	0: "id",
	1: "debuggerFullscreenUrl",
	2: "debuggerUrl",
	3: "faviconUrl",
	4: "title",
	5: "url",
}

// Decode decodes SessionLiveURLsPage from json.
func (s *SessionLiveURLsPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionLiveURLsPage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "debuggerFullscreenUrl":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DebuggerFullscreenUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"debuggerFullscreenUrl\"")
			}
		case "debuggerUrl":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DebuggerUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"debuggerUrl\"")
			}
		case "faviconUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FaviconUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconUrl\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionLiveURLsPage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionLiveURLsPage) {
					name = jsonFieldsNameOfSessionLiveURLsPage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionLiveURLsPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionLiveURLsPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionLog) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionLog) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("method")
		e.Str(s.Method)
	}
	{
		e.FieldStart("pageId")
		e.Int(s.PageId)
	}
	{
		e.FieldStart("sessionId")
		e.Str(s.SessionId)
	}
	{
		if s.FrameId.Set {
			e.FieldStart("frameId")
			s.FrameId.Encode(e)
		}
	}
	{
		if s.LoaderId.Set {
			e.FieldStart("loaderId")
			s.LoaderId.Encode(e)
		}
	}
	{
		if s.Request.Set {
			e.FieldStart("request")
			s.Request.Encode(e)
		}
	}
	{
		if s.Response.Set {
			e.FieldStart("response")
			s.Response.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionLog = [8]string{
	0: "method",
	1: "pageId",
	2: "sessionId",
	3: "frameId",
	4: "loaderId",
	5: "request",
	6: "response",
	7: "timestamp",
}

// Decode decodes SessionLog from json.
func (s *SessionLog) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionLog to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "method":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Method = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "pageId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.PageId = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageId\"")
			}
		case "sessionId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SessionId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionId\"")
			}
		case "frameId":
			if err := func() error {
				s.FrameId.Reset()
				if err := s.FrameId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frameId\"")
			}
		case "loaderId":
			if err := func() error {
				s.LoaderId.Reset()
				if err := s.LoaderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loaderId\"")
			}
		case "request":
			if err := func() error {
				s.Request.Reset()
				if err := s.Request.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request\"")
			}
		case "response":
			if err := func() error {
				s.Response.Reset()
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionLog")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionLog) {
					name = jsonFieldsNameOfSessionLog[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionLog) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionLog) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionLogRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionLogRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("params")
		s.Params.Encode(e)
	}
	{
		e.FieldStart("rawBody")
		e.Str(s.RawBody)
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionLogRequest = [3]string{
	0: "params",
	1: "rawBody",
	2: "timestamp",
}

// Decode decodes SessionLogRequest from json.
func (s *SessionLogRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionLogRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "params":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Params.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"params\"")
			}
		case "rawBody":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RawBody = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawBody\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionLogRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionLogRequest) {
					name = jsonFieldsNameOfSessionLogRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionLogRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionLogRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SessionLogRequestParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SessionLogRequestParams) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SessionLogRequestParams from json.
func (s *SessionLogRequestParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionLogRequestParams to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionLogRequestParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionLogRequestParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionLogRequestParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionLogResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionLogResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rawBody")
		e.Str(s.RawBody)
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
}

var jsonFieldsNameOfSessionLogResponse = [3]string{
	0: "rawBody",
	1: "result",
	2: "timestamp",
}

// Decode decodes SessionLogResponse from json.
func (s *SessionLogResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionLogResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rawBody":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RawBody = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawBody\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionLogResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionLogResponse) {
					name = jsonFieldsNameOfSessionLogResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionLogResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionLogResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SessionLogResponseResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SessionLogResponseResult) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SessionLogResponseResult from json.
func (s *SessionLogResponseResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionLogResponseResult to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionLogResponseResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionLogResponseResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionLogResponseResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionRecording) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionRecording) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		e.FieldStart("sessionId")
		e.Str(s.SessionId)
	}
	{
		e.FieldStart("timestamp")
		e.Int(s.Timestamp)
	}
	{
		e.FieldStart("type")
		e.Int(s.Type)
	}
}

var jsonFieldsNameOfSessionRecording = [4]string{
	0: "data",
	1: "sessionId",
	2: "timestamp",
	3: "type",
}

// Decode decodes SessionRecording from json.
func (s *SessionRecording) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionRecording to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "sessionId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SessionId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionId\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Timestamp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Type = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionRecording")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionRecording) {
					name = jsonFieldsNameOfSessionRecording[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionRecording) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionRecording) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SessionRecordingData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SessionRecordingData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SessionRecordingData from json.
func (s *SessionRecordingData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionRecordingData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionRecordingData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionRecordingData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionRecordingData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionRegion as json.
func (s SessionRegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SessionRegion from json.
func (s *SessionRegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionRegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SessionRegion(v) {
	case SessionRegionUsWest2:
		*s = SessionRegionUsWest2
	case SessionRegionUsEast1:
		*s = SessionRegionUsEast1
	case SessionRegionEuCentral1:
		*s = SessionRegionEuCentral1
	case SessionRegionApSoutheast1:
		*s = SessionRegionApSoutheast1
	default:
		*s = SessionRegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionStatus as json.
func (s SessionStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SessionStatus from json.
func (s *SessionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SessionStatus(v) {
	case SessionStatusRUNNING:
		*s = SessionStatusRUNNING
	case SessionStatusERROR:
		*s = SessionStatusERROR
	case SessionStatusTIMEDOUT:
		*s = SessionStatusTIMEDOUT
	case SessionStatusCOMPLETED:
		*s = SessionStatusCOMPLETED
	default:
		*s = SessionStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SessionUpdateParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SessionUpdateParams) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("projectId")
		e.Str(s.ProjectId)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfSessionUpdateParams = [2]string{
	0: "projectId",
	1: "status",
}

// Decode decodes SessionUpdateParams from json.
func (s *SessionUpdateParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionUpdateParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "projectId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ProjectId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionUpdateParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSessionUpdateParams) {
					name = jsonFieldsNameOfSessionUpdateParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SessionUpdateParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionUpdateParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SessionUpdateParamsStatus as json.
func (s SessionUpdateParamsStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SessionUpdateParamsStatus from json.
func (s *SessionUpdateParamsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionUpdateParamsStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SessionUpdateParamsStatus(v) {
	case SessionUpdateParamsStatusREQUESTRELEASE:
		*s = SessionUpdateParamsStatusREQUESTRELEASE
	default:
		*s = SessionUpdateParamsStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionUpdateParamsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionUpdateParamsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SessionUserMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SessionUserMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SessionUserMetadata from json.
func (s *SessionUserMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SessionUserMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SessionUserMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SessionUserMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SessionUserMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UploadCreateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UploadCreateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfUploadCreateResponse = [1]string{
	0: "message",
}

// Decode decodes UploadCreateResponse from json.
func (s *UploadCreateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UploadCreateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UploadCreateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUploadCreateResponse) {
					name = jsonFieldsNameOfUploadCreateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UploadCreateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UploadCreateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
